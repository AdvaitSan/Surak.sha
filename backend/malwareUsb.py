from flask import Flask, jsonify
from flask_socketio import SocketIO
from flask_cors import CORS
import os
import platform
import time
import threading
import psutil
import hashlib
import requests
import mimetypes  # used instead of magic

app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

VT_API_KEY = ""
VT_API_BASE = "https://www.virustotal.com/api/v3"

connected_drives = set()

def get_drive_list():
    drives = set()
    if platform.system() == "Windows":
        import win32api
        for drive in win32api.GetLogicalDriveStrings().split('\000')[:-1]:
            drives.add(drive)
    else:
        for part in psutil.disk_partitions():
            if 'removable' in part.opts or 'usb' in part.opts:
                drives.add(part.mountpoint)
    return drives

def upload_to_virustotal(file_path):
    try:
        url = f"{VT_API_BASE}/files"
        headers = { "x-apikey": VT_API_KEY }
        with open(file_path, "rb") as f:
            files = { "file": (os.path.basename(file_path), f) }
            response = requests.post(url, headers=headers, files=files)
            if response.status_code == 200:
                print(f"[VT] Uploaded file to VirusTotal: {file_path}")
            else:
                print(f"[VT] Upload failed: {response.status_code} - {response.text}")
    except Exception as e:
        print(f"[VT] Error uploading file: {e}")

def scan_file(file_path):
    try:
        # Get file type based on extension
        mimetype, _ = mimetypes.guess_type(file_path)

        # Skip common harmless types
        if mimetype and ("image/" in mimetype or "text/plain" in mimetype):
            return False

        with open(file_path, 'rb') as f:
            file_bytes = f.read()
            file_hash = hashlib.sha256(file_bytes).hexdigest()

        headers = { "x-apikey": VT_API_KEY }
        response = requests.get(f"{VT_API_BASE}/files/{file_hash}", headers=headers)

        if response.status_code == 200:
            data = response.json()
            stats = data["data"]["attributes"]["last_analysis_stats"]
            if stats["malicious"] > 0 or stats["suspicious"] > 0:
                print(f"[VT] Malware detected in file: {file_path}")
                return True
        elif response.status_code == 404:
            print(f"[VT] Hash not found. Uploading file to VirusTotal: {file_path}")
            upload_to_virustotal(file_path)
        else:
            print(f"[VT] Error {response.status_code}: {response.text}")

        return False
    except Exception as e:
        print(f"Error scanning {file_path}: {e}")
        return False

def scan_drive(drive_path):
    suspicious_files = []
    for root, dirs, files in os.walk(drive_path):
        for file in files:
            file_path = os.path.join(root, file)
            try:
                if scan_file(file_path):
                    suspicious_files.append(file_path)
                    if suspicious_files:
                        socketio.emit('malware_alert', {
                            'drive': drive_path,
                            'files': suspicious_files
                        })
                        return True
            except:
                pass
    return len(suspicious_files) > 0

def monitor_drives():
    global connected_drives
    initial_drives = get_drive_list()
    connected_drives = initial_drives

    while True:
        current_drives = get_drive_list()
        new_drives = current_drives - connected_drives
        for drive in new_drives:
            print(f"New drive detected: {drive}")
            socketio.emit('usb_connected', {'drive': drive})
            threading.Thread(target=lambda: scan_and_notify(drive)).start()

        connected_drives = current_drives
        time.sleep(2)

def scan_and_notify(drive):
    socketio.emit('scan_started', {'drive': drive})
    malware_found = scan_drive(drive)
    if not malware_found:
        socketio.emit('scan_complete', {
            'drive': drive,
            'status': 'clean'
        })

@app.route('/api/drives')
def get_drives():
    drives = list(connected_drives)
    return jsonify({'drives': drives})

@socketio.on('connect')
def handle_connect():
    print("Client connected")

if __name__ == '__main__':
    thread = threading.Thread(target=monitor_drives)
    thread.daemon = True
    thread.start()
    socketio.run(app, debug=True, port=5000)
